---
title: "파티셔닝"
description: "테이블 파티셔닝 전략(Range, List, Hash)과 관리 방법을 배웁니다."
difficulty: "advanced"
tags: ["postgresql", "partitioning", "performance"]
minVersion: 13
lastUpdated: "2026-02-28"
related: ["advanced/indexes", "advanced/performance"]
---

import { SQLPlayground } from '@/components/content/SQLPlayground'
import { Callout } from '@/components/content/Callout'

# 파티셔닝

대용량 테이블을 더 작은 물리적 조각으로 분할하여 관리와 성능을 개선합니다.

## 파티셔닝 전략

| 전략 | 분할 기준 | 적합한 경우 |
|------|-----------|-------------|
| **Range** | 범위 (날짜, 숫자) | 시계열 데이터 |
| **List** | 값 목록 | 카테고리, 지역 |
| **Hash** | 해시 함수 | 균등 분배 |

## Range 파티셔닝

```sql
-- 부모 테이블
CREATE TABLE logs (
  id BIGINT GENERATED ALWAYS AS IDENTITY,
  created_at TIMESTAMPTZ NOT NULL,
  message TEXT
) PARTITION BY RANGE (created_at);

-- 월별 파티션
CREATE TABLE logs_2026_01 PARTITION OF logs
  FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE logs_2026_02 PARTITION OF logs
  FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

CREATE TABLE logs_2026_03 PARTITION OF logs
  FOR VALUES FROM ('2026-03-01') TO ('2026-04-01');
```

<SQLPlayground
  defaultQuery={`CREATE TABLE sales (
  id BIGINT GENERATED ALWAYS AS IDENTITY,
  sold_at DATE NOT NULL,
  product TEXT NOT NULL,
  amount INTEGER NOT NULL
) PARTITION BY RANGE (sold_at);

CREATE TABLE sales_2026_q1 PARTITION OF sales
  FOR VALUES FROM ('2026-01-01') TO ('2026-04-01');
CREATE TABLE sales_2026_q2 PARTITION OF sales
  FOR VALUES FROM ('2026-04-01') TO ('2026-07-01');

INSERT INTO sales (sold_at, product, amount) VALUES
  ('2026-01-15', '노트북', 1200000),
  ('2026-02-20', '키보드', 89000),
  ('2026-05-10', '마우스', 35000);

SELECT tableoid::regclass AS partition, * FROM sales ORDER BY sold_at;`}
  title="Range 파티셔닝"
/>

## List 파티셔닝

```sql
CREATE TABLE orders (
  id SERIAL,
  region TEXT NOT NULL,
  total NUMERIC
) PARTITION BY LIST (region);

CREATE TABLE orders_kr PARTITION OF orders FOR VALUES IN ('KR');
CREATE TABLE orders_us PARTITION OF orders FOR VALUES IN ('US');
CREATE TABLE orders_jp PARTITION OF orders FOR VALUES IN ('JP');
```

## 파티션 프루닝

PostgreSQL은 쿼리 조건에 맞는 파티션만 검색합니다:

```sql
-- logs_2026_01 파티션만 스캔
EXPLAIN SELECT * FROM logs WHERE created_at = '2026-01-15';
```

<Callout type="info">
파티션 프루닝은 `WHERE` 조건에 파티션 키가 포함되어 있을 때 자동으로 작동합니다. 파티션 키 없는 쿼리는 모든 파티션을 스캔합니다.
</Callout>

## 파티션 관리

```sql
-- 파티션 분리 (데이터 보존)
ALTER TABLE logs DETACH PARTITION logs_2026_01;

-- 파티션 첨부
ALTER TABLE logs ATTACH PARTITION logs_2026_01
  FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

-- 오래된 파티션 삭제
DROP TABLE logs_2025_01;
```

## 다음 단계

파티셔닝을 배웠습니다. 다음 레슨에서는 EXPLAIN ANALYZE를 활용한 성능 최적화를 배웁니다.
