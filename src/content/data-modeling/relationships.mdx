---
title: "관계와 조인"
description: "외래 키로 테이블 간 관계를 정의하고 JOIN으로 데이터를 연결하는 방법을 배웁니다."
difficulty: "beginner"
tags: ["postgresql", "sql", "foreign-key", "join", "relationships"]
minVersion: 13
lastUpdated: "2026-02-28"
related: ["data-modeling/tables", "intermediate/joins"]
---

import { SQLPlayground } from '@/components/content/SQLPlayground'
import { Callout } from '@/components/content/Callout'

# 관계와 조인

관계형 데이터베이스의 핵심은 테이블 간의 **관계(Relationship)**입니다.

## 관계의 종류

```
1:1   ─  사용자 ↔ 프로필 (한 사용자에 하나의 프로필)
1:N   ─  부서 ↔ 직원 (한 부서에 여러 직원)
M:N   ─  학생 ↔ 수업 (여러 학생이 여러 수업)
```

## 1:N 관계 - 외래 키

```sql
CREATE TABLE departments (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  department_id INTEGER REFERENCES departments(id)
);
```

## JOIN - 테이블 연결

### INNER JOIN

양쪽 테이블에 모두 일치하는 행만 반환합니다:

```sql
SELECT e.name, d.name AS department
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;
```

### LEFT JOIN

왼쪽 테이블의 모든 행 + 오른쪽 매칭되는 행:

```sql
SELECT e.name, d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;
```

<SQLPlayground
  defaultQuery={`CREATE TABLE departments (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  department_id INTEGER REFERENCES departments(id)
);

INSERT INTO departments (name) VALUES ('개발팀'), ('디자인팀'), ('인사팀');
INSERT INTO employees (name, department_id) VALUES
  ('김철수', 1), ('이영희', 1), ('박민수', 2),
  ('정수진', NULL);

-- LEFT JOIN: 부서가 없는 직원도 표시
SELECT e.name AS employee, d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;`}
  title="LEFT JOIN 예제"
/>

## M:N 관계 - 중간 테이블

다대다 관계는 중간(junction) 테이블을 통해 구현합니다:

```sql
CREATE TABLE students (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE courses (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL
);

-- 중간 테이블
CREATE TABLE enrollments (
  student_id INTEGER REFERENCES students(id),
  course_id INTEGER REFERENCES courses(id),
  enrolled_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (student_id, course_id)
);
```

<SQLPlayground
  defaultQuery={`CREATE TABLE students (id SERIAL PRIMARY KEY, name TEXT NOT NULL);
CREATE TABLE courses (id SERIAL PRIMARY KEY, title TEXT NOT NULL);
CREATE TABLE enrollments (
  student_id INTEGER REFERENCES students(id),
  course_id INTEGER REFERENCES courses(id),
  PRIMARY KEY (student_id, course_id)
);

INSERT INTO students (name) VALUES ('김철수'), ('이영희'), ('박민수');
INSERT INTO courses (title) VALUES ('SQL 기초'), ('데이터 모델링'), ('성능 최적화');
INSERT INTO enrollments (student_id, course_id) VALUES
  (1, 1), (1, 2), (2, 1), (2, 3), (3, 2);

SELECT s.name AS student, c.title AS course
FROM enrollments e
JOIN students s ON e.student_id = s.id
JOIN courses c ON e.course_id = c.id
ORDER BY s.name;`}
  title="M:N 관계 조회"
/>

## 외래 키 동작 옵션

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id)
    ON DELETE CASCADE      -- 사용자 삭제 시 주문도 삭제
    ON UPDATE CASCADE      -- 사용자 ID 변경 시 주문의 참조도 변경
);
```

| 옵션 | 설명 |
|------|------|
| `CASCADE` | 참조된 행과 함께 삭제/수정 |
| `SET NULL` | 참조 컬럼을 NULL로 설정 |
| `SET DEFAULT` | 참조 컬럼을 기본값으로 설정 |
| `RESTRICT` | 참조 중이면 삭제/수정 거부 (기본값) |

<Callout type="warning">
`ON DELETE CASCADE`는 편리하지만 위험할 수 있습니다. 실수로 부모 행을 삭제하면 모든 관련 데이터가 함께 삭제됩니다. 중요한 데이터에는 `RESTRICT`를 사용하세요.
</Callout>

## 다음 단계

관계와 JOIN의 기본을 배웠습니다. 다음 레슨에서는 정규화를 통해 효율적인 데이터 구조를 설계하는 방법을 배웁니다.
