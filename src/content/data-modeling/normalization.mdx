---
title: "정규화"
description: "1NF, 2NF, 3NF 정규화를 통해 데이터 중복을 줄이고 무결성을 높이는 방법을 배웁니다."
difficulty: "beginner"
tags: ["postgresql", "normalization", "database-design"]
minVersion: 13
lastUpdated: "2026-02-28"
related: ["data-modeling/tables", "data-modeling/relationships"]
---

import { Callout } from '@/components/content/Callout'
import { SQLPlayground } from '@/components/content/SQLPlayground'

# 정규화

**정규화(Normalization)**는 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위한 테이블 설계 기법입니다.

## 왜 정규화가 필요한가?

비정규화된 테이블의 문제점:

```
orders 테이블 (비정규화)
┌──────┬────────┬────────────┬──────────┬────────┐
│ id   │ 고객명  │ 고객 이메일 │ 상품명    │ 가격   │
├──────┼────────┼────────────┼──────────┼────────┤
│ 1    │ 김철수  │ kim@ex.com │ 노트북   │ 120만  │
│ 2    │ 김철수  │ kim@ex.com │ 마우스   │ 3.5만  │
│ 3    │ 이영희  │ lee@ex.com │ 노트북   │ 120만  │
└──────┴────────┴────────────┴──────────┴────────┘
```

문제점:
- **갱신 이상**: 김철수 이메일 변경 시 여러 행을 수정해야 함
- **삽입 이상**: 주문 없이 고객 정보만 저장 불가
- **삭제 이상**: 주문 삭제 시 고객 정보도 함께 사라짐

## 제1정규형 (1NF)

**규칙**: 모든 컬럼이 원자값(atomic value)을 가져야 합니다.

```
-- 위반: 한 컬럼에 여러 값
┌──────┬───────────────────────┐
│ 이름 │ 전화번호               │
├──────┼───────────────────────┤
│ 김철수│ 010-1234, 02-5678    │ ← 위반!
└──────┴───────────────────────┘

-- 1NF 준수: 별도 테이블로 분리
users 테이블:     phone_numbers 테이블:
┌────┬───────┐   ┌─────────┬──────────┐
│ id │ 이름  │   │ user_id │ 전화번호  │
├────┼───────┤   ├─────────┼──────────┤
│ 1  │ 김철수│   │ 1       │ 010-1234 │
└────┴───────┘   │ 1       │ 02-5678  │
                  └─────────┴──────────┘
```

## 제2정규형 (2NF)

**규칙**: 1NF + 모든 비키 컬럼이 기본키 전체에 완전 함수적 종속.

복합 키의 일부에만 종속되는 컬럼을 분리합니다:

```
-- 위반: 상품명은 (주문ID, 상품ID) 중 상품ID에만 종속
┌──────────┬──────────┬──────────┬──────┐
│ order_id │ prod_id  │ 상품명    │ 수량 │
├──────────┼──────────┼──────────┼──────┤
│ 1        │ 101      │ 노트북    │ 1   │
└──────────┴──────────┴──────────┴──────┘

-- 2NF 준수: 상품 정보를 별도 테이블로
```

## 제3정규형 (3NF)

**규칙**: 2NF + 이행적 종속 제거. 비키 컬럼이 다른 비키 컬럼에 종속되면 안 됩니다.

```
-- 위반: 부서명은 부서ID에 종속 (이행적 종속)
employees:
┌────┬──────┬──────────┬──────────┐
│ id │ 이름 │ dept_id  │ 부서명    │
└────┴──────┴──────────┴──────────┘

-- 3NF 준수: 부서 정보를 별도 테이블로
employees:              departments:
┌────┬──────┬─────────┐ ┌────┬─────────┐
│ id │ 이름 │ dept_id │ │ id │ 부서명   │
└────┴──────┴─────────┘ └────┴─────────┘
```

<SQLPlayground
  defaultQuery={`-- 정규화된 테이블 설계 예시
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL
);

CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  price NUMERIC(10,2) NOT NULL
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INTEGER REFERENCES customers(id),
  ordered_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE order_items (
  order_id INTEGER REFERENCES orders(id),
  product_id INTEGER REFERENCES products(id),
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  PRIMARY KEY (order_id, product_id)
);

INSERT INTO customers (name, email) VALUES ('김철수', 'kim@ex.com'), ('이영희', 'lee@ex.com');
INSERT INTO products (name, price) VALUES ('노트북', 1200000), ('마우스', 35000);
INSERT INTO orders (customer_id) VALUES (1), (1), (2);
INSERT INTO order_items VALUES (1, 1, 1), (1, 2, 2), (2, 2, 1), (3, 1, 1);

SELECT c.name, p.name AS product, oi.quantity, p.price * oi.quantity AS total
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN customers c ON o.customer_id = c.id
JOIN products p ON oi.product_id = p.id;`}
  title="정규화된 테이블 설계"
/>

## 언제 비정규화를 고려할까?

<Callout type="info">
정규화가 항상 최선은 아닙니다. 읽기 성능이 중요한 경우 의도적으로 비정규화할 수 있습니다:
- 자주 JOIN하는 데이터를 하나의 테이블에 저장
- 집계 결과를 미리 계산하여 저장
- JSONB를 사용한 유연한 데이터 모델링
</Callout>

## 다음 단계

정규화를 배웠습니다. 다음 섹션에서는 JOIN 심화, 서브쿼리, 윈도우 함수 등 중급 주제를 다룹니다.
