---
title: "서브쿼리와 CTE"
description: "서브쿼리, EXISTS, CTE(Common Table Expression), 재귀 CTE를 배웁니다."
difficulty: "intermediate"
tags: ["postgresql", "sql", "subquery", "cte"]
minVersion: 13
lastUpdated: "2026-02-28"
related: ["intermediate/joins", "intermediate/window-functions"]
---

import { SQLPlayground } from '@/components/content/SQLPlayground'
import { Callout } from '@/components/content/Callout'

# 서브쿼리와 CTE

복잡한 쿼리를 단계별로 구성하는 방법을 배웁니다.

## 스칼라 서브쿼리

하나의 값을 반환하는 서브쿼리:

```sql
SELECT name, salary,
  salary - (SELECT AVG(salary) FROM employees) AS diff_from_avg
FROM employees;
```

## WHERE 절 서브쿼리

```sql
-- 평균 급여 이상인 직원
SELECT name, salary
FROM employees
WHERE salary >= (SELECT AVG(salary) FROM employees);

-- IN 서브쿼리
SELECT * FROM products
WHERE category_id IN (SELECT id FROM categories WHERE name LIKE '%전자%');
```

## EXISTS

행의 존재 여부를 확인합니다:

```sql
-- 주문이 있는 고객만 조회
SELECT name FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```

<Callout type="tip">
`EXISTS`는 조건 충족 시 즉시 반환하므로, 대용량 데이터에서 `IN`보다 효율적인 경우가 많습니다.
</Callout>

## CTE (Common Table Expression)

`WITH` 절로 임시 결과 집합에 이름을 붙입니다:

```sql
WITH department_stats AS (
  SELECT
    department_id,
    AVG(salary) AS avg_salary,
    COUNT(*) AS member_count
  FROM employees
  GROUP BY department_id
)
SELECT
  d.name,
  ds.avg_salary,
  ds.member_count
FROM department_stats ds
JOIN departments d ON ds.department_id = d.id;
```

<SQLPlayground
  defaultQuery={`CREATE TABLE departments (id SERIAL PRIMARY KEY, name TEXT NOT NULL);
CREATE TABLE employees (id SERIAL PRIMARY KEY, name TEXT, department_id INTEGER, salary INTEGER);

INSERT INTO departments (name) VALUES ('개발팀'), ('디자인팀'), ('기획팀');
INSERT INTO employees (name, department_id, salary) VALUES
  ('김철수', 1, 6000), ('이영희', 1, 4000), ('박민수', 2, 5500),
  ('정수진', 1, 6500), ('한지민', 3, 5000);

WITH dept_stats AS (
  SELECT department_id, ROUND(AVG(salary)) AS avg_sal, COUNT(*) AS cnt
  FROM employees GROUP BY department_id
)
SELECT d.name, ds.avg_sal, ds.cnt
FROM dept_stats ds JOIN departments d ON ds.department_id = d.id
ORDER BY ds.avg_sal DESC;`}
  title="CTE 예제"
/>

## 재귀 CTE

자기 참조 데이터(트리, 그래프)를 처리합니다:

```sql
-- 조직도 계층 구조 조회
WITH RECURSIVE org_tree AS (
  -- 기본 케이스: 최상위 관리자
  SELECT id, name, manager_id, 1 AS depth
  FROM employees
  WHERE manager_id IS NULL

  UNION ALL

  -- 재귀 케이스: 하위 직원
  SELECT e.id, e.name, e.manager_id, t.depth + 1
  FROM employees e
  JOIN org_tree t ON e.manager_id = t.id
)
SELECT REPEAT('  ', depth - 1) || name AS org_chart, depth
FROM org_tree
ORDER BY depth, name;
```

<Callout type="warning">
재귀 CTE는 종료 조건 없이 무한 루프에 빠질 수 있습니다. 안전장치로 `LIMIT`이나 `depth` 제한을 추가하세요.
</Callout>

## 다음 단계

서브쿼리와 CTE를 배웠습니다. 다음 레슨에서는 윈도우 함수를 배웁니다.
